// yo cuando variables de entorno
// Verificar que estamos en el navegador antes de usar window
const POKEMON_API_BASE = (typeof window !== 'undefined' && window.CONFIG?.POKEMON_API_URL) || "https://pokeapi.co/api/v2/"; // el "?" es para que no se da√±e si no existe window.CONFIG (fallback)
// esto es para evitar hacerle hardcode a la URL en el c√≥digo

// Endpoint 1: Obtener informaci√≥n de una ubicaci√≥n
async function getLocation(locationName) {
  try {
    let response = await fetch(`${POKEMON_API_BASE}location/${locationName}`);
    if (!response.ok) throw new Error("No hay net - location");
    let data = await response.json();
    console.log(`üìç Ubicaci√≥n: ${data.name}`, data);
    return data;
  } catch (error) {
    console.error("La cagu√© obteniendo location", error);
  }
}

// Endpoint 2: Obtener informaci√≥n de un √°rea espec√≠fica de ubicaci√≥n
async function getLocationArea(areaName) {
  try {
    let response = await fetch(`${POKEMON_API_BASE}location-area/${areaName}`);
    if (!response.ok) throw new Error("No hay net - location area");
    let data = await response.json();
    console.log(`üèûÔ∏è √Årea: ${data.name}`, data);
    return data;
  } catch (error) {
    console.error("La cagu√© obteniendo location area", error);
  }
}

// Endpoint 3: Obtener detalles de un Pokemon espec√≠fico
async function getPokemonDetails(pokemonNameOrUrl) {
  try {
    // Si recibimos una URL completa, √∫sala; si no, construye la URL
    const url = pokemonNameOrUrl.startsWith('http') 
      ? pokemonNameOrUrl 
      : `${POKEMON_API_BASE}pokemon/${pokemonNameOrUrl}`;
    
    let response = await fetch(url);
    if (!response.ok) throw new Error("No hay net - pokemon");
    let data = await response.json();
    console.log(`üêæ Pokemon: ${data.name}`, data);
    return data;
  } catch (error) {
    console.error("La cagu√© obteniendo pokemon", error);
  }
}

// Endpoint 4: Obtener todas las √°reas v√°lidas de una regi√≥n
async function getRegionAreas(regionName) {
  try {
    console.log(`üó∫Ô∏è Buscando √°reas v√°lidas en la regi√≥n: ${regionName}`);
    
    // 1. Obtener datos de la regi√≥n
    let response = await fetch(`${POKEMON_API_BASE}region/${regionName}`);
    if (!response.ok) throw new Error("No hay net - region");
    let regionData = await response.json();
    
    console.log(`üìç Regi√≥n encontrada: ${regionData.name}`);
    
    // 2. Extraer todas las locations de la regi√≥n
    const validLocations = regionData.locations.map(location => {
      // Extraer el nombre de la URL (ej: "/location/1/" ‚Üí "1")
      const locationId = location.url.split('/').filter(Boolean).pop();
      return {
        name: location.name,
        id: locationId,
        url: location.url
      };
    });
    
    console.log(`üéØ Encontradas ${validLocations.length} locations v√°lidas en ${regionName}:`);
    validLocations.forEach(loc => console.log(`  ‚Ä¢ ${loc.name}`));
    
    return {
      region: regionName,
      locationCount: validLocations.length,
      validLocations: validLocations
    };
    
  } catch (error) {
    console.error("La cagu√© obteniendo region", error);
    return null;
  }
}

// Funci√≥n principal: Obtener tipos de Pokemon en un √°rea espec√≠fica
async function getPokemonTypesInArea(areaName) {
  try {
    console.log(`üîç Buscando tipos de Pokemon en el √°rea: ${areaName}`);
    
    // 1. Obtener datos del √°rea
    const areaData = await getLocationArea(areaName);
    if (!areaData || !areaData.pokemon_encounters) {
      console.log("‚ùå No se encontraron Pokemon en esta √°rea");
      return [];
    }

    console.log(`üìä Encontrados ${areaData.pokemon_encounters.length} Pokemon en el √°rea`);

    // 2. Obtener detalles de cada Pokemon para extraer sus tipos
    const pokemonTypes = new Set(); // Usar Set para evitar duplicados
    const pokemonList = [];

    for (let encounter of areaData.pokemon_encounters.slice(0, 10)) { // L√≠mite de 10 para evitar muchas llamadas
      const pokemonData = await getPokemonDetails(encounter.pokemon.url);
      
      if (pokemonData && pokemonData.types) {
        // Guardar info del Pokemon
        pokemonList.push({
          name: pokemonData.name,
          types: pokemonData.types.map(t => t.type.name)
        });

        // Agregar tipos al Set
        pokemonData.types.forEach(typeInfo => {
          pokemonTypes.add(typeInfo.type.name);
        });
      }
    }

    const uniqueTypes = Array.from(pokemonTypes);
    
    console.log(`üéØ Tipos √∫nicos encontrados en ${areaName}:`, uniqueTypes);
    console.log(`üìã Pokemon analizados:`, pokemonList);

    return {
      area: areaName,
      uniqueTypes: uniqueTypes,
      pokemonCount: pokemonList.length,
      pokemonList: pokemonList
    };

  } catch (error) {
    console.error("La cagu√© en la funci√≥n principal", error);
  }
}

// Funci√≥n extra: Buscar Pokemon en m√∫ltiples √°reas de una regi√≥n
async function searchPokemonInRegion(regionName, maxAreas = 3) {
  console.log(`üîç B√∫squeda completa de Pokemon en la regi√≥n: ${regionName}`);
  
  try {
    // 1. Obtener √°reas v√°lidas
    const regionData = await getRegionAreas(regionName);
    if (!regionData || !regionData.validLocations.length) {
      console.log("‚ùå No se encontraron √°reas v√°lidas en esta regi√≥n");
      return;
    }
    
    // 2. Buscar Pokemon en las primeras 'maxAreas' locations
    const results = [];
    for (let i = 0; i < Math.min(maxAreas, regionData.validLocations.length); i++) {
      const location = regionData.validLocations[i];
      console.log(`\nüîç Analizando: ${location.name}`);
      
      const pokemonResult = await getPokemonTypesInArea(`${location.name}-area`);
      if (pokemonResult && pokemonResult.pokemonCount > 0) {
        results.push(pokemonResult);
      }
    }
    
    // 3. Resumen final
    console.log(`\nüìä RESUMEN DE ${regionName.toUpperCase()}:`);
    console.log(`‚Ä¢ √Åreas analizadas: ${results.length}`);
    console.log(`‚Ä¢ Total Pokemon √∫nicos encontrados: ${results.reduce((sum, r) => sum + r.pokemonCount, 0)}`);
    
    return results;
    
  } catch (error) {
    console.error("Error en b√∫squeda regional:", error);
  }
}

// Demo: Ejecutar las funciones para mostrar el uso de m√∫ltiples endpoints
async function runDemo() {
  console.log("üöÄ Iniciando demo con m√∫ltiples endpoints de PokeAPI");
  
  try {
    // Ejemplo 1: Buscar √°reas v√°lidas en Kanto
    console.log("=".repeat(60));
    const kantoAreas = await getRegionAreas("sinnoh");
    
    if (kantoAreas && kantoAreas.validLocations.length > 0) {
      // Ejemplo 2: Usar una de las √°reas v√°lidas encontradas
      console.log("\n" + "=".repeat(60) + "\n");
      const firstLocation = kantoAreas.validLocations[0].name;
      console.log(`üéØ Probando con la primera location v√°lida: ${firstLocation}`);
      
      await getLocation(firstLocation);
      
      // Ejemplo 3: Buscar Pokemon en un √°rea espec√≠fica
      console.log("\n" + "=".repeat(60) + "\n");
      const result = await getPokemonTypesInArea(`${firstLocation}-area`);
      
      console.log("\nüéâ Resultado final:");
      console.log(result);
    }
    
    console.log("\n" + "=".repeat(60) + "\n");
    
    // Ejemplo 4: Obtener un Pokemon espec√≠fico
    
    
  } catch (error) {
    console.error("Error en el demo:", error);
  }
}

// Ejecutar el demo
runDemo();

